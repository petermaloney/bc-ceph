#!/bin/bash
#
# Licensed GNU GPLv2; if you did not recieve a copy of the license, get one at http://www.gnu.org/licenses/gpl-2.0.html

usage() {
    echo "$0 [-j <size>] [-c <cluster>] [-d <osddevice>] [--bcache <cache_device>] [--no-start] --journal <journal-device> <serial>"
    echo "The bcache and journal device are not the partition but the device with the partition table. The partition does not need to exist, and will be created. If a partition exists with a label that matches the serial, it will be used."
    
    # TODO: the above comment is wrong about bcache... it does not make a partition
    # to fix that, I guess we need a new argument for size of bcache device
}

# journals are supposed to be something like 1GiB, but let's just make some extra... the ssd is too huge anyway and this is still nothing
# this is GiB, not GB
journal_size=16G
cluster=ceph
osddevice=
bcache=
journal=
start=1

while [ "$#" != 0 ]; do
    if [ "$1" = "-j" ]; then
        journal_size="$2"
        shift
    elif [ "$1" = "-c" ]; then
        cluster="$2"
        shift
    elif [ "$1" = "-d" ]; then
        osddevice="$2"
        shift
    elif [ "$1" = "--bcache" ]; then
        bcache="$2"
        shift
    elif [ "$1" = "--journal" ]; then
        journal="$2"
        shift
    elif [ "$1" = "--no-start" ]; then
        start=0
    else
        args+=("$1")
    fi
    shift
done

serial="${args[0]}"

hostname=$(hostname -s)
raw_osddevice="$osddevice"

if [ -z "$journal" ]; then
    echo "ERROR: journal is required"
    usage
    exit 1
fi
if [ -z "$journal" -o ! -e "$journal" ]; then
    echo "ERROR: journal \"$journal\" does not exist"
    exit 1
fi

check_deps() {
    abort=false
    
    cmds=(sgdisk smartctl parted mkfs.xfs diff awk ceph ceph-osd)
    if [ -n "$bcache" ]; then
        cmds+=(bcache-super-show make-bcache)
    fi
    for cmd in "${cmds[@]}"; do
        if ! which "${cmd}" >/dev/null 2>&1; then
            echo "ERROR: ${cmd} is not installed... aborting" >&2
            abort=true
        fi
    done
    
    if [ "$abort" = true ]; then
        exit 1
    fi
}

check_deps

make_bcache() {
    local raw_osddevice="$1"
    local bcache="$2"
    
    if ! lsmod | grep -q ^bcache; then
        echo "Waiting for bcache kernel module to load (for /sys/fs/bcache to appear)..."
        modprobe bcache
        while [ ! -e /sys/fs/bcache ]; do sleep 0.1; done
        
        if ! grep -q bcache /etc/initramfs-tools/modules; then
            echo bcache >> /etc/initramfs-tools/modules
            update-initramfs -uk all
        fi
    fi
    
    make-bcache -B "$raw_osddevice"
    echo "$raw_osddevice" > /sys/fs/bcache/register 2>/dev/null
    
    
    ## FIXME: this link disappears after some time... so don't trust it. Find out the /dev/bacheX name another way.
    #bcache_dev_uuid=$(bcache-super-show "$raw_osddevice" | awk '$1=="dev.uuid"{print $2}')
    #osddevice=/dev/bcache/by-uuid/"$bcache_dev_uuid"
    
    ## Tesing this fix
    disk_name=$(basename "$(readlink -f "$raw_osddevice")")
    bcache_name=$(basename "$(readlink -f "/sys/block/${disk_name}/bcache/dev")")
    # osddevice is global
    osddevice="/dev/$bcache_name"
    #
    
    echo "Waiting for bcache device to appear..."
    while [ ! -e "$osddevice" ]; do sleep 0.1; done

    
    # attach cache
    cache_found=($(stat -c %n /dev/disk/by-partlabel/*-bcache))
    if [ "${#cache_found[@]}" != 1 ]; then
        echo "ERROR: expected 1 cache device /dev/disk/by-partlabel/*-bcache but found:" >&2
        ls -l /dev/disk/by-partlabel/*-bcache >&2
        return 1
    fi
    
    csetuuid=$(bcache-super-show "${cache_found[0]}" | awk '$1 == "cset.uuid" {print $2}')
    echo "$csetuuid" > "/sys/block/${bcache_name}/bcache/attach"
    
    echo writeback > "/sys/block/${bcache_name}/bcache/cache_mode"
}

# find devices by serial
find_by_serial() {
    local serial="$1"
    
    if [ "${serial:0:4}" = "/dev" ]; then
        if [ ! -e "$serial" ]; then
            echo "osd serial \"$serial\" looks like a dev node, but the file doesn't exist... quitting"
            exit 1
        fi
        # it's not a serial, but a dev node... so just assume it's good and use it
        echo "$serial"
        return
    fi
    
    local device=
    for d in /sys/class/block/sd[a-z]*; do
        if grep -q "[0-9]$" <<< "$d"; then
            continue
        fi
        n=$(basename "$d")
        dserial=$(smartctl -i /dev/"$n" | awk '/Serial [Nn]umber:/ {print $NF}')

        if [ "$serial" = "$dserial" ]; then
            device="/dev/$n"
            break
        fi
    done

    echo "$device"
}

create_journal() {
    local serial="$1"
    local journal="$2"

    local suffix=
    if [ "${serial:0:4}" = "/dev" ]; then
        suffix=$(tr / _ <<< "${serial:5}")
    else
        suffix="$serial"
    fi

    local name="journal_${suffix}"
    local path="/dev/disk/by-partlabel/${name}"
    
    if [ -e "$path" ]; then
        #TODO: by default, error, but have a --force option which will ddd0 it
        echo "ERROR: osd journal already exists: $name" >&2
        return 1
    fi
    
    # sgdisk 0.8.8 on Ubuntu 14.04 doesn't support "0:..." in the -c option to set a name, so we fallback to this mess
    old=$(sgdisk -Pp "$journal")

    # this will create a GPT table if there isn't one
    # and it will make the partition and give it a name
    new=$(sgdisk -n 0:0:+"$journal_size" -Pp "$journal")

    d=$(diff -u0 <(echo "$old") <(echo "$new") | tail -n1)
    if ! grep -qE "\+  [0-9]+[ ]+[0-9]+[ ]+[0-9]+[ ]+$(grep -Eo '[0-9]+'<<< "$journal_size")" <<< "$d"; then
        echo "ERROR: the sgdisk name workaround failed... giving up. The diff between old and new partition table:"
        echo "$d"
        return 1
    fi
    start=$(awk '{print $3}' <<< "$d")
    end=$(awk '{print $4}' <<< "$d")
    
    parted -s "$journal" mkpart "$name" "$start"s "$end"s >/dev/null 2>&1
    if [ "$?" != 0 ]; then
        return 1
    fi
    
    echo "$path"
}

ddd0() {
    for device in "$@"; do
        if [ -z "$device" ]; then
            echo "USAGE: ddd0 <device>"
            return 1
        fi
        s=$(blockdev --getsize64 "$device")
        dd if=/dev/zero of="$device" bs=1M count=10 >/dev/null 2>&1 | grep -vE "records|copied|No space left" >&2
        dd if=/dev/zero of="$device" bs=1M seek=$((s-10485760)) oflag=seek_bytes 2>&1 | grep -vE "records|copied|No space left" >&2
    done
}

fail() {
    echo "$@" >&2
    exit 1
}

if [ -z "$osddevice" ]; then
    osddevice=$(find_by_serial "$serial")
    if [ -z "$raw_osddevice" ]; then
        raw_osddevice="$osddevice"
    fi
fi
if [ -z "$osddevice" ]; then
    fail "couldn't find serial for osd device \"$osddevice\""
fi
if [ ! -e "$osddevice" ]; then
    fail "couldn't find osd device \"$osddevice\""
fi

echo "Creating journal on device $journal for serial $serial"
journaldevice=$(create_journal "$serial" "$journal")
if [ $? != 0 ]; then
    exit 1
fi

if [ -n "$bcache" ]; then
    echo "Creating bcache backing device $raw_osddevice and attaching cache from $journal"
    make_bcache "$raw_osddevice" "$bcache"
fi

# weight is TB in the device; ceph docs suggest this
s=$(blockdev --getsize64 "$osddevice")
weight=$(echo "scale=4; $s / 1000/1000/1000/1000" | bc)

echo "Cleaning out device $osddevice"
ddd0 "$osddevice"

echo "Cleaning out device $journalddevice"
ddd0 "$journaldevice"

echo "Creating osd"
osd_uuid=$(uuidgen)
osd_number=$(ceph osd create "$osd_uuid")

# some cleanup...
ceph auth del "osd.$osd_number"
ceph osd crush rm osd."$osd_number"

mkdir -p "/var/lib/ceph/osd/${cluster}-${osd_number}"
echo "Creating filesystem"
mkfs.xfs -L "osd.$osd_number" -i size=2048 -l sectsize=4096 -d sectsize=4096 "$osddevice"

# for mount, doc said to use '-o user_xattr', but my machine says that's unknown for xfs
xfs_uuid=$(blkid -o value -s UUID "$osddevice")
if [ -z "$xfs_uuid" ]; then
    echo "ERROR: cannot find uuid of $osddevice" >&2
    exit 1
fi
sed -i -r "s|(.*/var/lib/ceph/osd/${cluster}-${osd_number}[^0-9].*)|#\1|" /etc/fstab
echo "UUID=$xfs_uuid /var/lib/ceph/osd/${cluster}-${osd_number} xfs noatime,nodiratime,logbsize=256k,logbufs=8,inode64,nofail 0 2" >> /etc/fstab
mount "/var/lib/ceph/osd/${cluster}-${osd_number}" || fail "couldn't mount osd data dir"

ceph-osd -i ${osd_number} --osd-journal="$journaldevice" --mkfs --mkkey --osd-uuid "$osd_uuid"

if [ -n "$journaldevice" -a ! -e "/var/lib/ceph/osd/${cluster}-${osd_number}/journal" ]; then
    # for some reason, ceph-osd doesn't remember where its journal is... so add a link
    ln -s "$journaldevice" "/var/lib/ceph/osd/${cluster}-${osd_number}/journal"
fi

ceph auth add osd.${osd_number} osd 'allow *' mon 'allow profile osd' -i "/var/lib/ceph/osd/${cluster}-${osd_number}/keyring"

ceph --cluster "$cluster" osd crush add-bucket "$hostname" host
ceph osd crush move "$hostname" root=default
ceph --cluster "$cluster" osd crush add osd."$osd_number" "$weight" host="$hostname"

# TODO: detect which init the system uses, and use that
touch "/var/lib/ceph/osd/${cluster}-${osd_number}/sysvinit"

chown -R ceph:ceph "/var/lib/ceph/osd/${cluster}-${osd_number}" 
chown -R ceph:ceph "$(readlink -f "$journaldevice")"
if [ "$start" = 1 ]; then
    service ceph start osd.${osd_number}
fi
