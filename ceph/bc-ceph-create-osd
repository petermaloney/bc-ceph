#!/bin/bash
#
# Licensed GNU GPLv2; if you did not recieve a copy of the license, get one at http://www.gnu.org/licenses/gpl-2.0.html

# The osd device will be wiped and all data destroyed.
# The journal device is handled with more care, and will only create partitions.
# The partition table will be created if the journal is colocated, but is required to exist already for separate journals.
# The partition for the separate journal and bcache does not need to exist, and will be created.
# The bcache and journal device are not the partition but the device with the partition table.
# The osd device is expected to be a whole disk.
# If you use a serial, make sure it's unique as seen by smartctl or it will break something. Use -d to override the osddevice and set a custom serial if they aren't unique.

usage() {
    echo "$0 [--fs {xfs|ext4|btrfs}] [-w <weight>] [-j <size>] [-c <cluster>] [-d <osddevice>] [--bcache <cache_device>] [--no-start] [--journal <journal-device>] <serial>"
    
    # TODO: the above comment is wrong about bcache... it does not make a partition
    # to fix that, I guess we need a new argument for size of bcache device
}

weight=
# journals are supposed to be something like 1GiB, but let's just make some extra... the ssd is too huge anyway and this is still nothing
# this is GiB, not GB
journal_size=16G
cluster=ceph
osddevice=
bcache=
journal=
start=1
colocated=false
fs=xfs

while [ "$#" != 0 ]; do
    if [ "$1" = "-j" ]; then
        journal_size="$2"
        shift
    elif [ "$1" = "-w" ]; then
        weight="$2"
        shift
    elif [ "$1" = "-c" ]; then
        cluster="$2"
        shift
    elif [ "$1" = "-d" ]; then
        osddevice="$2"
        shift
    elif [ "$1" = "--bcache" ]; then
        bcache="$2"
        shift
    elif [ "$1" = "--journal" ]; then
        journal="$2"
        shift
    elif [ "$1" = "--no-start" ]; then
        start=0
    elif [ "$1" = "--fs" ]; then
        fs="$2"
        shift
    else
        args+=("$1")
    fi
    shift
done

serial="${args[0]}"

hostname=$(hostname -s)
raw_osddevice="$osddevice"

if [ -z "$journal" ]; then
    colocated=true
    journal="$osddevice"
fi
if [ -n "$journal" -a ! -e "$journal" ]; then
    echo "ERROR: journal \"$journal\" does not exist"
    usage
    exit 1
fi
if [ -z "$serial" ]; then
    echo "ERROR: serial is required. If the disk does not have a serial, such as a VM, give a fake one eg. \"osd0\" and set -d too"
    usage
    exit 1
fi

check_deps() {
    abort=false
    
    cmds=(sgdisk smartctl parted mkfs.xfs diff awk ceph ceph-osd bc)
    if [ -n "$bcache" ]; then
        cmds+=(bcache-super-show make-bcache)
    fi
    for cmd in "${cmds[@]}"; do
        if ! which "${cmd}" >/dev/null 2>&1; then
            echo "ERROR: ${cmd} is not installed... aborting" >&2
            abort=true
        fi
    done
    
    if [ "$abort" = true ]; then
        exit 1
    fi
}

check_deps

# Creates the bcache backing device and attaches it to the cache
# It assumes the bcache cache device has a partlabel ending in "-bcache", and aborts if there are multiple matches.
make_bcache() {
    local raw_osddevice="$1"
    local bcache="$2"
    
    if ! lsmod | grep -q ^bcache; then
        echo "Waiting for bcache kernel module to load (for /sys/fs/bcache to appear)..."
        modprobe bcache
        while [ ! -e /sys/fs/bcache ]; do sleep 0.1; done
        
        if ! grep -q bcache /etc/initramfs-tools/modules; then
            echo bcache >> /etc/initramfs-tools/modules
            update-initramfs -uk all
        fi
    fi
    
    make-bcache -B "$raw_osddevice"
    echo "$raw_osddevice" > /sys/fs/bcache/register 2>/dev/null
    
    
    ## FIXME: this link disappears after some time... so don't trust it. Find out the /dev/bacheX name another way.
    #bcache_dev_uuid=$(bcache-super-show "$raw_osddevice" | awk '$1=="dev.uuid"{print $2}')
    #osddevice=/dev/bcache/by-uuid/"$bcache_dev_uuid"
    
    ## Tesing this fix
    disk_name=$(basename "$(readlink -f "$raw_osddevice")")
    bcache_name=$(basename "$(readlink -f "/sys/block/${disk_name}/bcache/dev")")
    # osddevice is global
    osddevice="/dev/$bcache_name"
    #
    
    echo "Waiting for bcache device to appear..."
    while [ ! -e "$osddevice" ]; do sleep 0.1; done

    
    # attach cache
    cache_found=($(stat -c %n /dev/disk/by-partlabel/*-bcache))
    
    # TODO: this code is old, and was assuming there was just 1 cache, and ignores the disk specified by --bcache. Instead, look at all partitions on the disk specified and use the first with a bcache header and type cache
    
    if [ "${#cache_found[@]}" != 1 ]; then
        echo "ERROR: expected 1 cache device /dev/disk/by-partlabel/*-bcache but found:" >&2
        ls -l /dev/disk/by-partlabel/*-bcache >&2
        return 1
    fi
    
    csetuuid=$(bcache-super-show "${cache_found[0]}" | awk '$1 == "cset.uuid" {print $2}')
    echo "$csetuuid" > "/sys/block/${bcache_name}/bcache/attach"
    
    echo writeback > "/sys/block/${bcache_name}/bcache/cache_mode"
}

# find devices by serial
# DO NOT use it on devices behind a LUN unless you're sure the serial seen by smartctl is unique.
# If you do not have a unique serial seen by smartctl, use the -d option to specify the device (eg. /dev/disk/by-id/wwn-...), and make up your own unique serial.
find_by_serial() {
    local serial="$1"
    
    if [ "${serial:0:4}" = "/dev" ]; then
        if [ ! -e "$serial" ]; then
            echo "osd serial \"$serial\" looks like a dev node, but the file doesn't exist... quitting"
            exit 1
        fi
        # it's not a serial, but a dev node... so just assume it's good and use it
        echo "$serial"
        return
    fi
    
    local device=
    for d in /sys/class/block/sd[a-z]*; do
        if grep -q "[0-9]$" <<< "$d"; then
            continue
        fi
        n=$(basename "$d")
        dserial=$(smartctl -i /dev/"$n" | awk '/Serial [Nn]umber:/ {print $NF}')

        if [ "$serial" = "$dserial" ]; then
            device="/dev/$n"
            break
        fi
    done

    echo "$device"
}

# Creates a partition table and the partitions needed for both the osd data filesystem and the osd's journal on the same device.
create_journal_colocated() {
    local suffix="$1"
    local journal="$2"
    
    if ! parted -s "$journal" print | grep -Eq "Partition Table: gpt"; then
        # if no partition table, make one
        parted -s "$journal" mktable gpt >/dev/null 2>&1
        if [ "$?" != 0 ]; then
            echo "ERROR: failed to create partition table on \"$journal\"" >&2
            return 1
        fi
    fi
    
    # osddevice and journaldevice are global, so don't call this function inside $()
    osddevice="/dev/disk/by-partlabel/data_${suffix}"
    journaldevice="/dev/disk/by-partlabel/journal_${suffix}"

    # we check the labels separate from the device in case another device has the same labels
    if [ -e "$journaldevice" ]; then
        echo "ERROR: osd journal already exists: $name" >&2
        return 1
    fi
    if [ -e "$osddevice" ]; then
        echo "ERROR: osd data partition already exists: $name" >&2
        return 1
    fi
    
    lines=$(parted "$journal" -sm print | wc -l)
    if [ "$lines" -gt 2 ]; then
        echo "ERROR: The colocated journal+osd device already has partitions. Aborting." >&2
        return 1
    fi
    
    if ! sgdisk -n 0:0:+"$journal_size" "$journal" >/dev/null 2>&1; then
        echo  "ERROR: failed to create journal partition" >&2
        return 1
    fi
    if ! sgdisk -n 0:0:-1 "$journal" >/dev/null 2>&1; then
        echo "ERROR: failed to create osd data partition" >&2
        return 1
    fi
    
    if ! parted -s "$journal" name 1 "journal_${suffix}" >/dev/null 2>&1; then
        echo  "ERROR: failed to set journal partlabel" >&2
        return 1
    fi
    if ! parted -s "$journal" name 2 "data_${suffix}" >/dev/null 2>&1; then
        echo  "ERROR: failed to set data partlabel" >&2
        return 1
    fi
    
    # journaldevice seems to work just fine
    # don't know why, but this is sometimes neeeded or the osddevice link is not created
    if [ ! -e "$osddevice" ]; then
        udevadm trigger
        while [ ! -e "$osddevice" ]; do
            # the osddevice link can take a few seconds
            sleep 1
        done
    fi
}

# Creates the partition needed for an osd's separate journal.
create_journal_separate() {
    local suffix="$1"
    local journal="$2"

    local name="journal_${suffix}"
    local path="/dev/disk/by-partlabel/${name}"
    
    if [ -e "$path" ]; then
        #TODO: by default, error, but have a --force option which will ddd0 it
        echo "ERROR: osd journal already exists: $name" >&2
        return 1
    fi
    
    # sgdisk 0.8.8 on Ubuntu 14.04 doesn't support "0:..." in the -c option to set a name, so we fallback to this mess
    local old=$(sgdisk -Pp "$journal")

    # this will create a GPT table if there isn't one
    # and it will make the partition and give it a name
    # (all as a dry run, output only)
    local new=$(sgdisk -n 0:0:+"$journal_size" -Pp "$journal")

    local d=$(diff -u0 <(echo "$old") <(echo "$new") | tail -n1)
    if ! grep -qE "\+[ ]+[0-9]+[ ]+[0-9]+[ ]+[0-9]+[ ]+$(grep -Eo '[0-9]+'<<< "$journal_size")" <<< "$d"; then
        echo "ERROR: the sgdisk name workaround failed... giving up. The diff between old and new partition table:" >&2
        echo "$d" >&2
        return 1
    fi
    local start=$(awk '{print $3}' <<< "$d")
    local end=$(awk '{print $4}' <<< "$d")
    
    parted -s "$journal" mkpart "$name" "$start"s "$end"s >/dev/null 2>&1
    if [ "$?" != 0 ]; then
        echo "ERROR: creating a partition on \"$journal\" failed. Is there a GPT partition table?" >&2
        return 1
    fi
    
    while [ ! -e "$path" ]; do
        sleep 1
    done
    
    # journaldevice is global, so don't call this function inside $()
    journaldevice="${path}"
}

# Creates the partitions for separate journals and colocated osds and journals. See other create_journal_* functions.
create_journal() {
    local serial="$1"
    local journal="$2"
    
    local suffix=
    if [ "${serial:0:4}" = "/dev" ]; then
        suffix=$(tr / _ <<< "${serial:5}")
    else
        suffix="$serial"
    fi

    if [ "$colocated" = true ]; then
        create_journal_colocated "$suffix" "$journal"
        return $?
    else
        create_journal_separate "$suffix" "$journal"
        return $?
    fi
}

# Zeros the first 10 and last 10 MiB of a device to wipe out filesystem headers and superblocks. Unlike wipefs, it doesn't rely on any magic numbers to identify things to erase.
ddd0() {
    for device in "$@"; do
        if [ -z "$device" ]; then
            echo "USAGE: ddd0 <device>"
            return 1
        fi
        if [ ! -e "$device" ]; then
            echo "ERROR: device \"$device\" does not exist"
            return 1
        fi
        if [ ! -L "$device" -a ! -b "$device" -a ! -c "$devie" ]; then
            echo "ERROR: device \"$device\" is not a link or a special file"
            return 1
        fi
        s=$(blockdev --getsize64 "$device")
        dd if=/dev/zero of="$device" bs=1M count=10 >/dev/null 2>&1 | grep -vE "records|copied|No space left" >&2
        dd if=/dev/zero of="$device" bs=1M seek=$((s-10485760)) oflag=seek_bytes 2>&1 | grep -vE "records|copied|No space left" >&2
    done
}

fail() {
    echo "$@" >&2
    exit 1
}

if [ -z "$osddevice" ]; then
    osddevice=$(find_by_serial "$serial")
    if [ -z "$raw_osddevice" ]; then
        raw_osddevice="$osddevice"
    fi
else
    raw_osddevice="$osddevice"
fi
if [ -z "$osddevice" ]; then
    fail "couldn't find serial for osd device \"$osddevice\""
fi
if [ ! -e "$osddevice" ]; then
    fail "couldn't find osd device \"$osddevice\""
fi

echo "Creating journal on device $journal for serial $serial"
# this function sets journaldevice and osddevice, so we don't use $() to avoid a subshell
create_journal "$serial" "$journal"
if [ $? != 0 ]; then
    fail "failed to create journal"
fi
if [ -z "$journaldevice" -o ! -e "$journaldevice" -o ! -L "$journaldevice" ]; then
    fail "failed to get journal path... result = \"$journaldevice\""
fi
if [ -z "$osddevice" -o ! -e "$osddevice" ]; then
    fail "failed to get data device path... result = \"$osddevice\""
fi

if [ -n "$bcache" ]; then
    echo "Creating bcache backing device $raw_osddevice and attaching cache from $journal"
    make_bcache "$raw_osddevice" "$bcache"
fi

if [ -z "$weight" ]; then
    # weight is TB in the device; ceph docs suggest this
    s=$(blockdev --getsize64 "$osddevice")
    weight=$(echo "scale=4; $s / 1000/1000/1000/1000" | bc)
fi

echo "Cleaning out device $osddevice"
ddd0 "$osddevice"

echo "Cleaning out device $journaldevice"
ddd0 "$journaldevice"

echo "Creating osd"
osd_uuid=$(uuidgen)
osd_number=$(ceph osd create "$osd_uuid")

# some cleanup...
ceph auth del "osd.$osd_number" 2>&1 | grep -vE "entity .* does not exist"
ceph osd crush rm osd."$osd_number" 2>&1 | grep -vE "device .* does not appear in the crush map"

if [ -e "/var/lib/ceph/osd/${cluster}-${osd_number}" ]; then
    count=$(find "/var/lib/ceph/osd/${cluster}-${osd_number}" | wc -l)
    if [ "$count" != 1 ]; then
        echo "ERROR: \"/var/lib/ceph/osd/${cluster}-${osd_number}\" exists and is not empty"
        echo "    if the data there is junk, simply run:"
        echo "        rm -rf --one-file-system \"/var/lib/ceph/osd/${cluster}-${osd_number}\""
        echo "        umount -l \"/var/lib/ceph/osd/${cluster}-${osd_number}\""
        exit 1
    fi
fi

mkdir -p "/var/lib/ceph/osd/${cluster}-${osd_number}"
echo "Creating filesystem"
if [ "$fs" = "xfs" ]; then
    mkfs.xfs -L "osd.$osd_number" -i size=2048 -l sectsize=4096 -d sectsize=4096 "$osddevice"
    fs_options="noatime,nodiratime,logbsize=256k,logbufs=8,inode64,nofail"
elif [ "$fs" = "ext4" ]; then
    # TODO: figure out what else is needed... mkfs options, mount options, ceph.conf options
    # -F is needed to do it on a whole device
    mkfs.ext4 -F -L "osd.$osd_number" "$osddevice"
    fs_options="noatime,nodiratime,nofail,user_xattr,journal_async_commit"
elif [ "$fs" = "btrfs" ]; then
    # TODO: figure out what else is needed... mkfs options, mount options, ceph.conf options
    # I took -l and -n suggestions from http://ceph.com/community/ceph-performance-part-2-write-throughput-without-ssd-journals/
    mkfs.btrfs -l 16k -n 16k -L "osd.$osd_number" "$osddevice"
    fs_options="noatime,nodiratime,user_subvol_rm_allowed,nofail"
    
    # also for some reason this config ends up false, but it is probably supposed to be true for btrfs. Is that a conf option, or is it supposed to be auto-detected?
    #        "filestore_journal_parallel": "false",

else
    echo "ERROR: unsupported fs \"$fs\""
fi

# for mount, doc said to use '-o user_xattr', but my machine says that's unknown for xfs
xfs_uuid=$(blkid -o value -s UUID "$osddevice")
if [ -z "$xfs_uuid" ]; then
    echo "ERROR: cannot find uuid of $osddevice" >&2
    exit 1
fi
sed -i -r "s|(.*/var/lib/ceph/osd/${cluster}-${osd_number}[^0-9].*)|#\1|" /etc/fstab
echo "UUID=$xfs_uuid /var/lib/ceph/osd/${cluster}-${osd_number} ${fs} ${fs_options} 0 2" >> /etc/fstab
mount "/var/lib/ceph/osd/${cluster}-${osd_number}" || fail "couldn't mount osd data dir"

ceph-osd -i ${osd_number} --osd-journal="$journaldevice" --mkfs --mkkey --osd-uuid "$osd_uuid"

if [ -n "$journaldevice" -a ! -e "/var/lib/ceph/osd/${cluster}-${osd_number}/journal" ]; then
    # for some reason, ceph-osd doesn't remember where its journal is... so add a link
    ln -s "$journaldevice" "/var/lib/ceph/osd/${cluster}-${osd_number}/journal"
fi

ceph auth add osd.${osd_number} osd 'allow *' mon 'allow profile osd' -i "/var/lib/ceph/osd/${cluster}-${osd_number}/keyring"

ceph --cluster "$cluster" osd crush add-bucket "$hostname" host 2>&1 | grep -vE "bucket.*already exists"
ceph osd crush move "$hostname" root=default 2>&1 | grep -vE "no need to move item id .* to location .* in crush map"
ceph --cluster "$cluster" osd crush add osd."$osd_number" "$weight" host="$hostname"

if which systemctl >/dev/null 2>&1; then
    touch "/var/lib/ceph/osd/${cluster}-${osd_number}/systemd"
else
    # using sysvinit even with upstart
    touch "/var/lib/ceph/osd/${cluster}-${osd_number}/sysvinit"
fi

chown -R ceph:ceph "/var/lib/ceph/osd/${cluster}-${osd_number}" 
chown -R ceph:ceph "$(readlink -f "$journaldevice")"
if [ "$start" = 1 ]; then
    if which systemctl >/dev/null 2>&1; then
        systemctl start "ceph-osd@${osd_number}"
    else
        # using sysvinit even with upstart
        service ceph start "osd.${osd_number}"
    fi
fi
